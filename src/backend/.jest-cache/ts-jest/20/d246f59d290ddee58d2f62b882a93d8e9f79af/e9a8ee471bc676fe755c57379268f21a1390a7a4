[["/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/test/integration/auth.test.ts",{"fileContent":"// @package jest ^29.7.0\n// @package supertest ^6.3.3\n// @package typeorm ^0.3.17\n// @package winston ^3.11.0\n\nimport { describe, beforeAll, afterAll, beforeEach, it, expect } from '@jest/globals';\nimport { DataSource, Repository } from 'typeorm';\nimport supertest from 'supertest';\nimport { createLogger } from 'winston';\n\nimport { AuthService } from '../../src/services/auth.service';\nimport { MFAService } from '../../src/services/mfa.service';\nimport { User, UserRole } from '../../src/models/user.model';\nimport { authConfig } from '../../src/config/auth.config';\n\ndescribe('Authentication Service Integration Tests', () => {\n  let dataSource: DataSource;\n  let userRepository: Repository<User>;\n  let authService: AuthService;\n  let mfaService: MFAService;\n  let testUsers: { [key: string]: User } = {};\n  let logger: ReturnType<typeof createLogger>;\n\n  beforeAll(async () => {\n    // Initialize test database connection\n    dataSource = new DataSource({\n      type: 'postgres',\n      host: process.env.TEST_DB_HOST || 'localhost',\n      port: parseInt(process.env.TEST_DB_PORT || '5432'),\n      username: process.env.TEST_DB_USER || 'test',\n      password: process.env.TEST_DB_PASSWORD || 'test',\n      database: process.env.TEST_DB_NAME || 'auth_test',\n      entities: [User],\n      synchronize: true,\n      logging: false\n    });\n\n    await dataSource.initialize();\n    userRepository = dataSource.getRepository(User);\n    mfaService = new MFAService();\n    authService = new AuthService(userRepository, mfaService);\n\n    // Initialize logger\n    logger = createLogger({\n      level: 'info',\n      transports: [\n        new winston.transports.Console({\n          format: winston.format.combine(\n            winston.format.timestamp(),\n            winston.format.json()\n          )\n        })\n      ]\n    });\n\n    // Create test users for each role\n    await setupTestUsers();\n  });\n\n  afterAll(async () => {\n    // Cleanup test data\n    await userRepository.clear();\n    await dataSource.destroy();\n  });\n\n  beforeEach(async () => {\n    // Reset rate limiting and lockout status\n    for (const user of Object.values(testUsers)) {\n      user.loginAttempts = 0;\n      user.lockoutUntil = null;\n      await userRepository.save(user);\n    }\n  });\n\n  const setupTestUsers = async () => {\n    const users = [\n      {\n        email: 'admin@austa.health',\n        password: 'Admin@123456',\n        firstName: 'Admin',\n        lastName: 'User',\n        role: UserRole.ADMINISTRATOR,\n        mfaEnabled: true,\n        phoneNumber: '+5511999999991'\n      },\n      {\n        email: 'broker@austa.health',\n        password: 'Broker@123456',\n        firstName: 'Broker',\n        lastName: 'User',\n        role: UserRole.BROKER,\n        mfaEnabled: true,\n        phoneNumber: '+5511999999992'\n      },\n      {\n        email: 'beneficiary@austa.health',\n        password: 'User@123456',\n        firstName: 'Test',\n        lastName: 'Beneficiary',\n        role: UserRole.BENEFICIARY,\n        mfaEnabled: false\n      }\n    ];\n\n    for (const userData of users) {\n      const user = new User(userData);\n      testUsers[user.role] = await userRepository.save(user);\n    }\n  };\n\n  describe('Login Flow', () => {\n    it('should successfully authenticate admin with valid credentials', async () => {\n      const result = await authService.login(\n        testUsers.ADMINISTRATOR.email,\n        'Admin@123456',\n        '127.0.0.1'\n      );\n\n      expect(result.user).toBeDefined();\n      expect(result.tokens).toBeDefined();\n      expect(result.mfaRequired).toBe(true);\n      expect(result.user.role).toBe(UserRole.ADMINISTRATOR);\n    });\n\n    it('should enforce password complexity requirements', async () => {\n      await expect(\n        authService.login('admin@austa.health', 'weakpass', '127.0.0.1')\n      ).rejects.toThrow();\n    });\n\n    it('should implement rate limiting after failed attempts', async () => {\n      const attempts = authConfig.security.maxLoginAttempts + 1;\n      for (let i = 0; i < attempts; i++) {\n        try {\n          await authService.login(\n            testUsers.ADMINISTRATOR.email,\n            'WrongPass@123',\n            '127.0.0.1'\n          );\n        } catch (error) {\n          expect(error).toBeDefined();\n        }\n      }\n\n      const user = await userRepository.findOne({\n        where: { email: testUsers.ADMINISTRATOR.email }\n      });\n      expect(user?.lockoutUntil).toBeDefined();\n      expect(user?.loginAttempts).toBeGreaterThan(authConfig.security.maxLoginAttempts);\n    });\n\n    it('should maintain secure audit logs for login attempts', async () => {\n      const result = await authService.login(\n        testUsers.BROKER.email,\n        'Broker@123456',\n        '127.0.0.1'\n      );\n\n      const user = await userRepository.findOne({\n        where: { email: testUsers.BROKER.email }\n      });\n      expect(user?.auditLog).toContainEqual(\n        expect.objectContaining({\n          action: 'LOGIN',\n          ipAddress: '127.0.0.1'\n        })\n      );\n    });\n  });\n\n  describe('MFA Verification', () => {\n    it('should successfully verify TOTP for admin users', async () => {\n      const { secret } = await mfaService.setupTOTP(testUsers.ADMINISTRATOR);\n      testUsers.ADMINISTRATOR.mfaSecret = secret;\n      await userRepository.save(testUsers.ADMINISTRATOR);\n\n      const token = authenticator.generate(secret);\n      const result = await authService.verifyMFA(\n        testUsers.ADMINISTRATOR.id,\n        token,\n        'totp'\n      );\n\n      expect(result.verified).toBe(true);\n      expect(result.tokens).toBeDefined();\n    });\n\n    it('should successfully verify SMS token for broker users', async () => {\n      await mfaService.generateSMSToken(testUsers.BROKER);\n      const token = testUsers.BROKER.mfaSecret;\n\n      const result = await authService.verifyMFA(\n        testUsers.BROKER.id,\n        token!,\n        'sms'\n      );\n\n      expect(result.verified).toBe(true);\n      expect(result.tokens).toBeDefined();\n    });\n\n    it('should enforce MFA timeout period', async () => {\n      const { secret } = await mfaService.setupTOTP(testUsers.ADMINISTRATOR);\n      testUsers.ADMINISTRATOR.mfaSecret = secret;\n      await userRepository.save(testUsers.ADMINISTRATOR);\n\n      // Wait for token to expire\n      await new Promise(resolve => setTimeout(resolve, authConfig.mfa.tokenExpiry * 1000 + 1000));\n\n      const token = authenticator.generate(secret);\n      await expect(\n        authService.verifyMFA(testUsers.ADMINISTRATOR.id, token, 'totp')\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('Session Management', () => {\n    it('should enforce role-specific session durations', async () => {\n      const adminResult = await authService.login(\n        testUsers.ADMINISTRATOR.email,\n        'Admin@123456',\n        '127.0.0.1'\n      );\n      const beneficiaryResult = await authService.login(\n        testUsers.BENEFICIARY.email,\n        'User@123456',\n        '127.0.0.1'\n      );\n\n      const adminToken = jwt.decode(adminResult.tokens.accessToken) as any;\n      const beneficiaryToken = jwt.decode(beneficiaryResult.tokens.accessToken) as any;\n\n      expect(adminToken.exp - adminToken.iat).toBe(authConfig.session.administrator.duration);\n      expect(beneficiaryToken.exp - beneficiaryToken.iat).toBe(authConfig.session.beneficiary.duration);\n    });\n\n    it('should handle token refresh securely', async () => {\n      const loginResult = await authService.login(\n        testUsers.BROKER.email,\n        'Broker@123456',\n        '127.0.0.1'\n      );\n\n      const refreshResult = await authService.refreshToken(loginResult.tokens.refreshToken);\n      expect(refreshResult.accessToken).toBeDefined();\n      expect(refreshResult.refreshToken).toBeDefined();\n      expect(refreshResult.accessToken).not.toBe(loginResult.tokens.accessToken);\n    });\n\n    it('should implement secure logout', async () => {\n      const loginResult = await authService.login(\n        testUsers.ADMINISTRATOR.email,\n        'Admin@123456',\n        '127.0.0.1'\n      );\n\n      await authService.logout(testUsers.ADMINISTRATOR.id, loginResult.tokens.refreshToken);\n\n      // Verify token is invalidated\n      await expect(\n        authService.refreshToken(loginResult.tokens.refreshToken)\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('Security Compliance', () => {\n    it('should enforce LGPD consent requirements', async () => {\n      const user = testUsers.BENEFICIARY;\n      user.lgpdConsent = false;\n      await userRepository.save(user);\n\n      await expect(\n        authService.login(user.email, 'User@123456', '127.0.0.1')\n      ).rejects.toThrow(/LGPD consent required/);\n    });\n\n    it('should maintain comprehensive security audit logs', async () => {\n      const user = testUsers.ADMINISTRATOR;\n      const actions = ['LOGIN', 'MFA_VERIFY', 'TOKEN_REFRESH', 'LOGOUT'];\n\n      for (const action of actions) {\n        user.auditLog.push({\n          action,\n          timestamp: new Date(),\n          ipAddress: '127.0.0.1',\n          userAgent: 'test-agent'\n        });\n      }\n\n      await userRepository.save(user);\n      const updatedUser = await userRepository.findOne({\n        where: { id: user.id }\n      });\n\n      expect(updatedUser?.auditLog).toHaveLength(actions.length);\n      expect(updatedUser?.auditLog.map(log => log.action)).toEqual(expect.arrayContaining(actions));\n    });\n  });\n});","resolvedModuleNames":["/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/services/auth.service.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/services/mfa.service.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/models/user.model.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/config/auth.config.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/utils/encryption.ts"]}],["/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/test/unit/auth.test.ts",{"fileContent":"// @package jest ^29.7.0\n// @package typeorm ^0.3.17\n\nimport { describe, beforeEach, test, expect, jest } from '@jest/globals';\nimport { Repository } from 'typeorm';\nimport { AuthService } from '../../src/services/auth.service';\nimport { MFAService } from '../../src/services/mfa.service';\nimport { User, UserRole } from '../../src/models/user.model';\nimport { authConfig } from '../../src/config/auth.config';\n\ndescribe('AuthService', () => {\n  let authService: AuthService;\n  let mfaService: MFAService;\n  let userRepository: Repository<User>;\n  let mockUsers: Partial<User>[];\n\n  beforeEach(() => {\n    // Initialize mock repositories and services\n    userRepository = {\n      findOne: jest.fn(),\n      save: jest.fn(),\n    } as unknown as Repository<User>;\n\n    mfaService = {\n      isMFARequired: jest.fn(),\n      generateSMSToken: jest.fn(),\n      verifyTOTP: jest.fn(),\n      verifySMSToken: jest.fn(),\n    } as unknown as MFAService;\n\n    authService = new AuthService(userRepository, mfaService);\n\n    // Setup mock users for different roles\n    mockUsers = [\n      {\n        id: '1',\n        email: 'admin@austa.health',\n        password: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewKyNiLXCJzjKmOe', // \"Admin123!\"\n        role: UserRole.ADMINISTRATOR,\n        mfaEnabled: true,\n        loginAttempts: 0,\n      },\n      {\n        id: '2',\n        email: 'broker@austa.health',\n        password: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewKyNiLXCJzjKmOe', // \"Broker123!\"\n        role: UserRole.BROKER,\n        mfaEnabled: true,\n        phoneNumber: '+5511999999999',\n        loginAttempts: 0,\n      },\n      {\n        id: '3',\n        email: 'beneficiary@austa.health',\n        password: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewKyNiLXCJzjKmOe', // \"User123!\"\n        role: UserRole.BENEFICIARY,\n        mfaEnabled: false,\n        loginAttempts: 0,\n      },\n    ];\n  });\n\n  describe('login', () => {\n    test('should successfully authenticate administrator with MFA requirement', async () => {\n      const admin = mockUsers[0];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(admin);\n      (mfaService.isMFARequired as jest.Mock).mockResolvedValue(true);\n\n      const result = await authService.login(\n        admin.email!,\n        'Admin123!',\n        '127.0.0.1'\n      );\n\n      expect(result.user.id).toBe(admin.id);\n      expect(result.mfaRequired).toBe(true);\n      expect(result.tokens).toBeDefined();\n      expect(userRepository.save).toHaveBeenCalledWith(\n        expect.objectContaining({\n          id: admin.id,\n          loginAttempts: 0,\n          lastIpAddress: '127.0.0.1',\n        })\n      );\n    });\n\n    test('should successfully authenticate broker with SMS MFA', async () => {\n      const broker = mockUsers[1];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(broker);\n      (mfaService.isMFARequired as jest.Mock).mockResolvedValue(true);\n      (mfaService.generateSMSToken as jest.Mock).mockResolvedValue(undefined);\n\n      const result = await authService.login(\n        broker.email!,\n        'Broker123!',\n        '127.0.0.1'\n      );\n\n      expect(result.user.id).toBe(broker.id);\n      expect(result.mfaRequired).toBe(true);\n      expect(mfaService.generateSMSToken).toHaveBeenCalled();\n    });\n\n    test('should successfully authenticate beneficiary without MFA', async () => {\n      const beneficiary = mockUsers[2];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(beneficiary);\n      (mfaService.isMFARequired as jest.Mock).mockResolvedValue(false);\n\n      const result = await authService.login(\n        beneficiary.email!,\n        'User123!',\n        '127.0.0.1'\n      );\n\n      expect(result.user.id).toBe(beneficiary.id);\n      expect(result.mfaRequired).toBe(false);\n      expect(result.tokens).toBeDefined();\n    });\n\n    test('should lock account after maximum login attempts', async () => {\n      const admin = { ...mockUsers[0], loginAttempts: 4 };\n      (userRepository.findOne as jest.Mock).mockResolvedValue(admin);\n\n      await expect(\n        authService.login(admin.email!, 'WrongPassword', '127.0.0.1')\n      ).rejects.toThrow('Account temporarily locked');\n\n      expect(userRepository.save).toHaveBeenCalledWith(\n        expect.objectContaining({\n          id: admin.id,\n          loginAttempts: 5,\n          lockoutUntil: expect.any(Date),\n        })\n      );\n    });\n  });\n\n  describe('verifyMFA', () => {\n    test('should verify administrator TOTP token successfully', async () => {\n      const admin = mockUsers[0];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(admin);\n      (mfaService.verifyTOTP as jest.Mock).mockResolvedValue(true);\n\n      const result = await authService.verifyMFA(admin.id!, '123456', 'totp');\n\n      expect(result.verified).toBe(true);\n      expect(result.tokens).toBeDefined();\n    });\n\n    test('should verify broker SMS token successfully', async () => {\n      const broker = mockUsers[1];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(broker);\n      (mfaService.verifySMSToken as jest.Mock).mockResolvedValue(true);\n\n      const result = await authService.verifyMFA(broker.id!, '123456', 'sms');\n\n      expect(result.verified).toBe(true);\n      expect(result.tokens).toBeDefined();\n    });\n\n    test('should reject invalid MFA token', async () => {\n      const admin = mockUsers[0];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(admin);\n      (mfaService.verifyTOTP as jest.Mock).mockResolvedValue(false);\n\n      await expect(\n        authService.verifyMFA(admin.id!, 'invalid', 'totp')\n      ).rejects.toThrow('Invalid MFA token');\n    });\n  });\n\n  describe('sessionManagement', () => {\n    test('should enforce administrator session duration', async () => {\n      const admin = mockUsers[0];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(admin);\n      (mfaService.isMFARequired as jest.Mock).mockResolvedValue(true);\n\n      const result = await authService.login(\n        admin.email!,\n        'Admin123!',\n        '127.0.0.1'\n      );\n\n      const decodedToken = await authService.validateSession(\n        result.tokens.accessToken\n      );\n      const tokenDuration =\n        decodedToken.exp! - Math.floor(Date.now() / 1000);\n\n      expect(tokenDuration).toBeLessThanOrEqual(\n        authConfig.session.administrator.duration\n      );\n    });\n\n    test('should enforce broker session duration', async () => {\n      const broker = mockUsers[1];\n      (userRepository.findOne as jest.Mock).mockResolvedValue(broker);\n      (mfaService.isMFARequired as jest.Mock).mockResolvedValue(true);\n\n      const result = await authService.login(\n        broker.email!,\n        'Broker123!',\n        '127.0.0.1'\n      );\n\n      const decodedToken = await authService.validateSession(\n        result.tokens.accessToken\n      );\n      const tokenDuration =\n        decodedToken.exp! - Math.floor(Date.now() / 1000);\n\n      expect(tokenDuration).toBeLessThanOrEqual(\n        authConfig.session.broker.duration\n      );\n    });\n  });\n\n  describe('roleBasedAccess', () => {\n    test('should validate administrator access rights', async () => {\n      const admin = mockUsers[0];\n      const result = await authService.checkRoleAccess(\n        admin.role,\n        'MANAGE_USERS'\n      );\n      expect(result).toBe(true);\n    });\n\n    test('should validate broker access restrictions', async () => {\n      const broker = mockUsers[1];\n      const result = await authService.checkRoleAccess(\n        broker.role,\n        'VIEW_HEALTH_DATA'\n      );\n      expect(result).toBe(false);\n    });\n\n    test('should validate beneficiary access restrictions', async () => {\n      const beneficiary = mockUsers[2];\n      const result = await authService.checkRoleAccess(\n        beneficiary.role,\n        'VIEW_OWN_DATA'\n      );\n      expect(result).toBe(true);\n    });\n  });\n\n  describe('logout', () => {\n    test('should successfully logout and invalidate tokens', async () => {\n      const admin = mockUsers[0];\n      const refreshToken = 'valid-refresh-token';\n\n      await authService.logout(admin.id!, refreshToken);\n\n      // Verify token is blacklisted\n      await expect(\n        authService.refreshToken(refreshToken)\n      ).rejects.toThrow('Token has been invalidated');\n    });\n  });\n});","resolvedModuleNames":["/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/services/auth.service.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/services/mfa.service.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/models/user.model.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/config/auth.config.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/auth-service/src/utils/encryption.ts"]}],["/home/user/onboarding-portal-v3-hrqnmc/src/backend/api-gateway/test/integration/gateway.test.ts",{"fileContent":"import { describe, beforeAll, afterAll, beforeEach, afterEach, test, expect } from '@jest/globals'; // @version ^29.5.0\nimport supertest from 'supertest'; // @version ^6.3.3\nimport nock from 'nock'; // @version ^13.3.1\nimport Redis from 'ioredis-mock'; // @version ^8.2.2\nimport { metrics } from '@opentelemetry/api'; // @version ^1.4.0\nimport { app } from '../../src/index';\nimport { securityMiddleware } from '../../src/middleware/security';\nimport { rateLimiter } from '../../src/middleware/rate-limiter';\n\n// Test constants\nconst TEST_JWT_ADMIN = process.env.TEST_JWT_ADMIN;\nconst TEST_JWT_BROKER = process.env.TEST_JWT_BROKER;\nconst TEST_JWT_BENEFICIARY = process.env.TEST_JWT_BENEFICIARY;\n\nconst RATE_LIMIT_THRESHOLDS = {\n  ADMIN: 5000,\n  BROKER: 1000,\n  BENEFICIARY: 100\n};\n\nconst SERVICE_ENDPOINTS = {\n  AUTH: '/api/v1/auth',\n  HEALTH: '/api/v1/health',\n  ENROLLMENT: '/api/v1/enrollments',\n  POLICY: '/api/v1/policies',\n  DOCUMENT: '/api/v1/documents'\n};\n\n@describe('API Gateway Integration Tests')\nclass GatewayIntegrationTest {\n  private request: supertest.SuperTest<supertest.Test>;\n  private redisMock: Redis;\n  private serviceMocks: Map<string, nock.Scope>;\n  private metricsCollector: metrics.Meter;\n\n  constructor() {\n    this.request = supertest(app);\n    this.redisMock = new Redis();\n    this.serviceMocks = new Map();\n    this.metricsCollector = metrics.getMeterProvider().getMeter('api-gateway-tests');\n  }\n\n  @beforeAll\n  async setupTestEnvironment(): Promise<void> {\n    // Configure Redis mock\n    rateLimiter.createRateLimiter = jest.fn().mockImplementation(() => {\n      return async (req: any, res: any, next: any) => next();\n    });\n\n    // Initialize service mocks\n    Object.entries(SERVICE_ENDPOINTS).forEach(([service, endpoint]) => {\n      this.serviceMocks.set(service, nock(`http://localhost:3000`).persist());\n    });\n\n    // Configure monitoring\n    this.metricsCollector.createCounter('api_requests_total');\n    this.metricsCollector.createHistogram('api_request_duration_seconds');\n  }\n\n  @afterAll\n  async cleanupTestEnvironment(): Promise<void> {\n    await this.redisMock.quit();\n    nock.cleanAll();\n    this.serviceMocks.clear();\n    metrics.disable();\n  }\n\n  @beforeEach\n  async setupTest(): Promise<void> {\n    await this.redisMock.flushall();\n    nock.cleanAll();\n  }\n\n  @afterEach\n  async cleanupTest(): Promise<void> {\n    await this.redisMock.flushall();\n  }\n\n  @test\n  async testSecurityMiddleware(): Promise<void> {\n    // Test CORS headers\n    const corsResponse = await this.request\n      .options(SERVICE_ENDPOINTS.AUTH)\n      .set('Origin', 'http://localhost:3000');\n\n    expect(corsResponse.headers['access-control-allow-origin']).toBe('http://localhost:3000');\n    expect(corsResponse.headers['access-control-allow-methods']).toContain('GET');\n    expect(corsResponse.headers['strict-transport-security']).toBeDefined();\n\n    // Test JWT validation\n    const noAuthResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH);\n    expect(noAuthResponse.status).toBe(401);\n\n    const invalidJwtResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('Authorization', 'Bearer invalid');\n    expect(invalidJwtResponse.status).toBe(401);\n\n    // Test role-based access\n    const adminResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('Authorization', `Bearer ${TEST_JWT_ADMIN}`)\n      .set('x-totp-token', '123456');\n    expect(adminResponse.status).toBe(200);\n\n    // Test bot detection\n    const botResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('User-Agent', 'BadBot/1.0');\n    expect(botResponse.status).toBe(403);\n\n    // Test IP filtering\n    const blockedIpResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('X-Forwarded-For', '1.2.3.4');\n    expect(blockedIpResponse.status).toBe(403);\n  }\n\n  @test\n  async testRateLimiting(): Promise<void> {\n    // Test rate limit headers\n    const response = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('Authorization', `Bearer ${TEST_JWT_BROKER}`);\n\n    expect(response.headers['x-ratelimit-limit']).toBeDefined();\n    expect(response.headers['x-ratelimit-remaining']).toBeDefined();\n    expect(response.headers['x-ratelimit-reset']).toBeDefined();\n\n    // Test role-based limits\n    const requests = Array(RATE_LIMIT_THRESHOLDS.BROKER + 1).fill(null);\n    for (const _ of requests) {\n      await this.request\n        .get(SERVICE_ENDPOINTS.AUTH)\n        .set('Authorization', `Bearer ${TEST_JWT_BROKER}`);\n    }\n\n    const limitExceededResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('Authorization', `Bearer ${TEST_JWT_BROKER}`);\n    expect(limitExceededResponse.status).toBe(429);\n\n    // Test Redis cluster failover\n    await this.redisMock.quit();\n    const failoverResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('Authorization', `Bearer ${TEST_JWT_BROKER}`);\n    expect(failoverResponse.status).toBe(200);\n  }\n\n  @test\n  async testServiceRouting(): Promise<void> {\n    // Mock service responses\n    this.serviceMocks.get('AUTH')!\n      .get('/api/v1/auth')\n      .reply(200, { status: 'ok' });\n\n    this.serviceMocks.get('HEALTH')!\n      .get('/api/v1/health')\n      .reply(200, { status: 'healthy' });\n\n    // Test successful routing\n    const authResponse = await this.request\n      .get(SERVICE_ENDPOINTS.AUTH)\n      .set('Authorization', `Bearer ${TEST_JWT_ADMIN}`)\n      .set('x-totp-token', '123456');\n    expect(authResponse.status).toBe(200);\n\n    // Test circuit breaker\n    this.serviceMocks.get('HEALTH')!\n      .get('/api/v1/health')\n      .times(5)\n      .reply(500);\n\n    const circuitBreakerResponses = await Promise.all(\n      Array(6).fill(null).map(() => \n        this.request\n          .get(SERVICE_ENDPOINTS.HEALTH)\n          .set('Authorization', `Bearer ${TEST_JWT_ADMIN}`)\n          .set('x-totp-token', '123456')\n      )\n    );\n\n    expect(circuitBreakerResponses[5].status).toBe(503);\n  }\n\n  @test\n  async testMonitoring(): Promise<void> {\n    // Test metrics endpoint\n    const metricsResponse = await this.request\n      .get('/metrics')\n      .set('Authorization', `Bearer ${TEST_JWT_ADMIN}`)\n      .set('x-totp-token', '123456');\n\n    expect(metricsResponse.status).toBe(200);\n    expect(metricsResponse.type).toBe('text/plain');\n\n    // Verify metrics collection\n    const counter = this.metricsCollector.createCounter('test_requests');\n    counter.add(1);\n\n    const histogram = this.metricsCollector.createHistogram('test_latency');\n    histogram.record(100);\n\n    const metricsData = await this.request\n      .get('/metrics')\n      .set('Authorization', `Bearer ${TEST_JWT_ADMIN}`)\n      .set('x-totp-token', '123456');\n\n    expect(metricsData.text).toContain('test_requests_total');\n    expect(metricsData.text).toContain('test_latency_bucket');\n  }\n}\n\nexport default GatewayIntegrationTest;","resolvedModuleNames":["/home/user/onboarding-portal-v3-hrqnmc/src/backend/api-gateway/src/index.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/api-gateway/src/middleware/security.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/api-gateway/src/middleware/rate-limiter.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/api-gateway/src/config/kong.config.ts","/home/user/onboarding-portal-v3-hrqnmc/src/backend/api-gateway/src/middleware/cors.ts"]}]]